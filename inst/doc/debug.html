<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>The configuration list</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p>This vignette is a guide to debugging and testing <code>drake</code> projects. Please also see the <a href="https://github.com/ropensci/drake/blob/master/vignettes/caution.Rmd">&ldquo;caution&rdquo; vignette</a>, which addresses <code>drake</code>&#39;s known edge cases, pitfalls, and weaknesses that may or may not be fixed in future releases. For the most up-to-date information on unhandled edge cases, please visit the <a href="https://github.com/ropensci/drake/issues">issue tracker</a>, where you can submit your own bug reports as well. Be sure to search the closed issues too, especially if you are not using the most up-to-date development version.</p>

<h1>The configuration list</h1>

<p>Most of <code>drake</code>&#39;s functions rely on a central <code>config</code> list. An understanding of <code>config</code> will help you grasp the internals. <code>make()</code> and <code>drake_config()</code> both return the <code>config</code> list. Unlike <code>make()</code>, <code>drake_config()</code>&#39;s return value is visible, and its only purpose is to construct your <code>config</code>.</p>

<pre><code class="r">load_basic_example() # Get the code with drake_example(&quot;basic&quot;).
config &lt;- drake_config(my_plan)

sort(names(config))
##  [1] &quot;args&quot;               &quot;cache&quot;              &quot;cache_log_file&quot;    
##  [4] &quot;cache_path&quot;         &quot;caching&quot;            &quot;command&quot;           
##  [7] &quot;cpu&quot;                &quot;elapsed&quot;            &quot;envir&quot;             
## [10] &quot;evaluator&quot;          &quot;fetch_cache&quot;        &quot;graph&quot;             
## [13] &quot;hook&quot;               &quot;imports_only&quot;       &quot;jobs&quot;              
## [16] &quot;keep_going&quot;         &quot;lazy_load&quot;          &quot;log_progress&quot;      
## [19] &quot;long_hash_algo&quot;     &quot;parallelism&quot;        &quot;plan&quot;              
## [22] &quot;prepend&quot;            &quot;prework&quot;            &quot;recipe_command&quot;    
## [25] &quot;retries&quot;            &quot;seed&quot;               &quot;session_info&quot;      
## [28] &quot;short_hash_algo&quot;    &quot;skip_imports&quot;       &quot;skip_safety_checks&quot;
## [31] &quot;targets&quot;            &quot;timeout&quot;            &quot;trigger&quot;           
## [34] &quot;verbose&quot;
</code></pre>

<p>The fields of <code>config</code> mostly arguments to <code>make()</code> and are documented there. The rest of the fields are as follows.</p>

<ul>
<li><code>graph</code>: An <a href="https://github.com/igraph/rigraph">igraph</a> object with the directed acyclic graph (DAG) of the workflow.</li>
<li><code>inventory</code>: A running list of the cached objects in each <code>storr</code> namespace. Maintaining this list helps avoid repeated calls to <code>config$cache$list()</code>, which increases speed.</li>
<li><code>long_hash_algo</code>: Name of the long hash algorithm used throughout <code>make()</code>. Used to generate hash keys that <em>will not</em> become the names of files. See the <a href="https://github.com/ropensci/drake/blob/master/vignettes/storage.Rmd">storage vignette</a> for details.</li>
<li><code>seed</code>: The random number generator seed taken from the user&#39;s R session. Each target is built reproducibly using a deterministic function of this seed, and the build does not change the seed outside the scope of the target&#39;s command.</li>
<li><code>short_hash_algo</code>: Name of the short hash algorithm used throughout <code>make()</code>. Used to generate hash keys that could become names of files. See the <a href="https://github.com/ropensci/drake/blob/master/vignettes/storage.Rmd">storage vignette</a> for details.</li>
</ul>

<p>Early in <code>make()</code>, the <code>config</code> list is stored in the cache. You can retrieve it with</p>

<pre><code class="r">read_drake_config()
</code></pre>

<p>and you can access parts of it with some companion functions.</p>

<pre><code class="r">read_drake_graph()
read_drake_plan()
</code></pre>

<h1>Plan your work.</h1>

<h2>Workflow plan data frames</h2>

<p>The workflow plan data frame is your responsibility, and it takes effort and care. Fortunately, functions in <code>drake</code> can help. You can check the plan for formatting issues, missing input files, etc. with the <code>check_plan()</code> function.</p>

<pre><code class="r">load_basic_example() # Get the code with drake_example(&quot;basic&quot;).
my_plan
## # A tibble: 15 x 2
##    target                 command                                         
##    &lt;chr&gt;                  &lt;chr&gt;                                           
##  1 &quot;&quot;                     &quot;knit(knitr_in(\&quot;report.Rmd\&quot;), file_out(\&quot;repo~
##  2 small                  simulate(48)                                    
##  3 large                  simulate(64)                                    
##  4 regression1_small      reg1(small)                                     
##  5 regression1_large      reg1(large)                                     
##  6 regression2_small      reg2(small)                                     
##  7 regression2_large      reg2(large)                                     
##  8 summ_regression1_small suppressWarnings(summary(regression1_small$resi~
##  9 summ_regression1_large suppressWarnings(summary(regression1_large$resi~
## 10 summ_regression2_small suppressWarnings(summary(regression2_small$resi~
## 11 summ_regression2_large suppressWarnings(summary(regression2_large$resi~
## 12 coef_regression1_small suppressWarnings(summary(regression1_small))$co~
## 13 coef_regression1_large suppressWarnings(summary(regression1_large))$co~
## 14 coef_regression2_small suppressWarnings(summary(regression2_small))$co~
## 15 coef_regression2_large suppressWarnings(summary(regression2_large))$co~

check_plan(my_plan) # No issues.
</code></pre>

<h2>Visualize your workflow.</h2>

<p>After quality-checking your plan, you should check that you understand how the steps of your workflow are interconnected. The web of dependencies affects which targets are built and which ones are skipped during <code>make()</code>.</p>

<pre><code class="r"># Hover, click, drag, zoom, and pan. See args &#39;from&#39; and &#39;to&#39;.
config &lt;- drake_config(my_plan)
vis_drake_graph(config, width = &quot;100%&quot;, height = &quot;500px&quot;)
</code></pre>

<p><iframe
src = "https://ropensci.github.io/drake/images/outdated.html"
width = "100%" height = "600px" allowtransparency="true"
style="border: none; box-shadow: none">
</iframe></p>

<p>See the <a href="https://cran.r-project.org/package=drake/vignettes/graph.html">rendered graph vignette</a> to learn more about how graphing can help (for example, how to visualize small subgraphs). If you want to take control of your own <a href="http://datastorm-open.github.io/visNetwork/">visNetwork graph</a>, use the <code>dataframes_graph()</code> function to get data frames of nodes, edges, and legend nodes.</p>

<h2>Check dependency relationships.</h2>

<p>Programmatically, several functions can help you check immediate dependencies.</p>

<pre><code class="r">deps(reg2)
## [1] &quot;lm&quot;

# knitr_in() makes sure your target depends on `report.Rmd`
# and any dependencies loaded with loadd() and readd()
# in the report&#39;s active code chunks.
deps(my_plan$command[1])
## [1] &quot;\&quot;report.Rmd\&quot;&quot;         &quot;\&quot;report.md\&quot;&quot;         
## [3] &quot;coef_regression2_small&quot; &quot;knit&quot;                  
## [5] &quot;large&quot;                  &quot;small&quot;

deps(my_plan$command[nrow(my_plan)])
## [1] &quot;regression2_large&quot; &quot;summary&quot;           &quot;suppressWarnings&quot;
</code></pre>

<p><code>Drake</code> takes special precautions so that a target/import does not depend on itself. For example, <code>deps(f)</code> might return <code>&quot;f&quot;</code> if <code>f()</code> is a recursive function, but <code>make()</code> just ignores this conflict and runs as expected. In other words, <code>make()</code> automatically removes all self-referential loops in the dependency network.</p>

<p>List all the reproducibly-tracked objects and files, including imports and targets.</p>

<pre><code class="r">tracked(my_plan, targets = &quot;small&quot;)
## [1] &quot;data.frame&quot;  &quot;mtcars&quot;      &quot;random_rows&quot; &quot;nrow&quot;        &quot;sample.int&quot; 
## [6] &quot;small&quot;       &quot;simulate&quot;

tracked(my_plan)
##  [1] &quot;lm&quot;                     &quot;data.frame&quot;            
##  [3] &quot;mtcars&quot;                 &quot;random_rows&quot;           
##  [5] &quot;\&quot;report.Rmd\&quot;&quot;         &quot;nrow&quot;                  
##  [7] &quot;sample.int&quot;             &quot;coef_regression2_small&quot;
##  [9] &quot;knit&quot;                   &quot;large&quot;                 
## [11] &quot;small&quot;                  &quot;simulate&quot;              
## [13] &quot;reg1&quot;                   &quot;reg2&quot;                  
## [15] &quot;regression1_small&quot;      &quot;summary&quot;               
## [17] &quot;suppressWarnings&quot;       &quot;regression1_large&quot;     
## [19] &quot;regression2_small&quot;      &quot;regression2_large&quot;     
## [21] &quot;\&quot;report.md\&quot;&quot;          &quot;summ_regression1_small&quot;
## [23] &quot;summ_regression1_large&quot; &quot;summ_regression2_small&quot;
## [25] &quot;summ_regression2_large&quot; &quot;coef_regression1_small&quot;
## [27] &quot;coef_regression1_large&quot; &quot;coef_regression2_large&quot;
</code></pre>

<h2>Outdated, up to date, and missing items</h2>

<p><code>missed()</code> reports import dependencies missing from your environment</p>

<pre><code class="r">config &lt;- drake_config(my_plan, verbose = FALSE)
missed(config) # Nothing is missing right now.
## character(0)
</code></pre>

<p><code>outdated()</code> reports any targets that are outdated, plus any downstream targets that depend on them.</p>

<pre><code class="r">outdated(config)
##  [1] &quot;\&quot;report.md\&quot;&quot;          &quot;coef_regression1_large&quot;
##  [3] &quot;coef_regression1_small&quot; &quot;coef_regression2_large&quot;
##  [5] &quot;coef_regression2_small&quot; &quot;large&quot;                 
##  [7] &quot;regression1_large&quot;      &quot;regression1_small&quot;     
##  [9] &quot;regression2_large&quot;      &quot;regression2_small&quot;     
## [11] &quot;small&quot;                  &quot;summ_regression1_large&quot;
## [13] &quot;summ_regression1_small&quot; &quot;summ_regression2_large&quot;
## [15] &quot;summ_regression2_small&quot;
</code></pre>

<p>To find out why a target is out of date, you can load the <a href="https://github.com/richfitz/storr">storr</a>-based cache and compare the appropriate hash keys to the output of <code>dependency_profile()</code>. To use <code>dependency_profile()</code>, be sure to supply the master configuration list as the <code>config</code> argument. The same is true for <code>drake_meta()</code>, another alternative.</p>

<pre><code class="r">load_basic_example() # Get the code with drake_example(&quot;basic&quot;).
config &lt;- make(my_plan, verbose = FALSE)
# Change a dependency.
reg2 &lt;- function(d) {
  d$x3 &lt;- d$x ^ 3
  lm(y ~ x3, data = d)
}
outdated(config)
## [1] &quot;\&quot;report.md\&quot;&quot;          &quot;coef_regression2_large&quot;
## [3] &quot;coef_regression2_small&quot; &quot;regression2_large&quot;     
## [5] &quot;regression2_small&quot;      &quot;summ_regression2_large&quot;
## [7] &quot;summ_regression2_small&quot;

dependency_profile(target = &quot;regression2_small&quot;, config = config)
## $cached_command
## [1] &quot;{\n reg2(small) \n}&quot;
## 
## $current_command
## [1] &quot;{\n reg2(small) \n}&quot;
## 
## $cached_file_modification_time
## NULL
## 
## $cached_dependency_hash
## [1] &quot;bff91683ab896912a57d3010b489e68a50294f7c46dc5c8bc80797a3a616194b&quot;
## 
## $current_dependency_hash
## [1] &quot;8685dbd7c688d9ceca90b9c7cdde2e151e39a4882af35b18c9697a04c24e9d63&quot;
## 
## $hashes_of_dependencies
##               reg2              small 
## &quot;d47109544c89ca7a&quot; &quot;40fb781de184c741&quot;

drake_meta(target = &quot;regression2_small&quot;, config = config)
## $target
## [1] &quot;regression2_small&quot;
## 
## $imported
## [1] FALSE
## 
## $foreign
## [1] TRUE
## 
## $missing
## [1] FALSE
## 
## $seed
## [1] 1034257256
## 
## $command
## [1] &quot;{\n reg2(small) \n}&quot;
## 
## $depends
## [1] &quot;8685dbd7c688d9ceca90b9c7cdde2e151e39a4882af35b18c9697a04c24e9d63&quot;
## 
## $file
## [1] NA

config$cache$get_hash(key = &quot;small&quot;, namespace = &quot;kernels&quot;) # same
## [1] &quot;40fb781de184c741&quot;

config$cache$get_hash(key = &quot;small&quot;) # same
## [1] &quot;40fb781de184c741&quot;

config$cache$get_hash(key = &quot;reg2&quot;, namespace = &quot;kernels&quot;) # same
## [1] &quot;d47109544c89ca7a&quot;

config$cache$get_hash(key = &quot;reg2&quot;) # different
## [1] &quot;ec0c4b9499814ace&quot;
</code></pre>

<p>In <code>drake</code>, the &ldquo;kernel&rdquo; of a target or import is the piece of the output that is reproducibly tracked. For ordinary R objects, the kernel is just the object itself. For custom external files, it is a separate hash. But for functions, the kernel is the deparsed body of the function, together with the dependency hash if the function is imported (see <code>drake:::store_function()</code>).</p>

<p>The internal functions <code>drake:::meta()</code> and <code>drake:::meta_list()</code> compute the metadata on each target that <code>drake</code> uses to decide which targets to build and which to skip (via <code>drake:::should_build_target()</code>). Then, after the target/import is processed, <code>drake:::finish_meta()</code> updates the metadata (except for the <code>$missing</code> element) before it is cached. See <code>diagnose()</code> to read available metadata, along with any errors, warnings, and messages generated during the build.</p>

<pre><code class="r">str(diagnose(small))
## List of 11
##  $ target      : chr &quot;small&quot;
##  $ imported    : logi FALSE
##  $ foreign     : logi TRUE
##  $ missing     : logi TRUE
##  $ seed        : num 1.95e+09
##  $ command     : chr &quot;{\n simulate(48) \n}&quot;
##  $ depends     : chr &quot;5aa9da170b33b159cfd382e15229d7efe6d6a5777d1c69e71b0c6a1188ee5116&quot;
##  $ file        : chr NA
##  $ start       :Class &#39;proc_time&#39;  Named num [1:5] 24.884 0.613 31.978 0.298 0.147
##   .. ..- attr(*, &quot;names&quot;)= chr [1:5] &quot;user.self&quot; &quot;sys.self&quot; &quot;elapsed&quot; &quot;user.child&quot; ...
##  $ time_command:&#39;data.frame&#39;:    1 obs. of  5 variables:
##   ..$ item   : chr &quot;small&quot;
##   ..$ type   : chr &quot;target&quot;
##   ..$ elapsed: num 0.001
##   ..$ user   : num 0.001
##   ..$ system : num 0
##  $ time_build  :&#39;data.frame&#39;:    1 obs. of  5 variables:
##   ..$ item   : chr &quot;small&quot;
##   ..$ type   : chr &quot;target&quot;
##   ..$ elapsed: num 0.006
##   ..$ user   : num 0.005
##   ..$ system : num 0

str(diagnose(&quot;\&quot;report.md\&quot;&quot;))
## List of 12
##  $ target      : chr &quot;\&quot;report.md\&quot;&quot;
##  $ imported    : logi FALSE
##  $ foreign     : logi TRUE
##  $ missing     : logi TRUE
##  $ seed        : num 1.85e+09
##  $ command     : chr &quot;{\n knit(knitr_in(\&quot;report.Rmd\&quot;), file_out(\&quot;report.md\&quot;), quiet = TRUE) \n}&quot;
##  $ depends     : chr &quot;5f72f8f2a06b7a515e17a3ea3f57b1dd3522d7143e0cbd0650a3c0985683f81d&quot;
##  $ file        : chr &quot;ed35f108e2ccd75a904273f1e8559d5a0acb9c2700531276a7acdcfba09decc6&quot;
##  $ start       :Class &#39;proc_time&#39;  Named num [1:5] 25.061 0.617 32.159 0.298 0.147
##   .. ..- attr(*, &quot;names&quot;)= chr [1:5] &quot;user.self&quot; &quot;sys.self&quot; &quot;elapsed&quot; &quot;user.child&quot; ...
##  $ time_command:&#39;data.frame&#39;:    1 obs. of  5 variables:
##   ..$ item   : chr &quot;\&quot;report.md\&quot;&quot;
##   ..$ type   : chr &quot;target&quot;
##   ..$ elapsed: num 0.055
##   ..$ user   : num 0.054
##   ..$ system : num 0.001
##  $ mtime       : POSIXct[1:1], format: &quot;2018-03-22 13:13:09&quot;
##  $ time_build  :&#39;data.frame&#39;:    1 obs. of  5 variables:
##   ..$ item   : chr &quot;\&quot;report.md\&quot;&quot;
##   ..$ type   : chr &quot;target&quot;
##   ..$ elapsed: num 0.06
##   ..$ user   : num 0.059
##   ..$ system : num 0.001
</code></pre>

<p>If your target&#39;s last build succeeded, then <code>diagnose(your_target)</code> has the most current information from that build. But if your target failed, then only <code>diagnose(your_target)$error</code>, <code>diagnose(your_target)$warnings</code>, and <code>diagnose(your_target)$messages</code> correspond to the failure, and all the other metadata correspond to the last build that completed without an error.</p>

<h1>Test with triggers.</h1>

<p>To track dependencies and make decisions about what needs building, <code>make()</code> store the fingerprint, or hash, of each target. Hashing is great for detecting the right changes in targets, but if all you want to do is test and debug a workflow, the full rigor can be time-consuming.</p>

<p>Fortunately, you can change the triggers that tell <code>drake</code> when to (re)build each target. Below, <code>drake</code> disregards outdatedness and just builds the targets that are missing.</p>

<pre><code class="r">clean(verbose = FALSE) # Start from scratch
config &lt;- make(my_plan, trigger = &quot;missing&quot;)
## Unloading targets from environment:
##   small
##   large
##   coef_regression2_small
## target large: trigger &quot;missing&quot;
## target small: trigger &quot;missing&quot;
## target regression1_large: trigger &quot;missing&quot;
## target regression1_small: trigger &quot;missing&quot;
## target regression2_large: trigger &quot;missing&quot;
## target regression2_small: trigger &quot;missing&quot;
## target coef_regression1_large: trigger &quot;missing&quot;
## target coef_regression1_small: trigger &quot;missing&quot;
## target coef_regression2_large: trigger &quot;missing&quot;
## target coef_regression2_small: trigger &quot;missing&quot;
## target summ_regression1_large: trigger &quot;missing&quot;
## target summ_regression1_small: trigger &quot;missing&quot;
## target summ_regression2_large: trigger &quot;missing&quot;
## target summ_regression2_small: trigger &quot;missing&quot;
## target file &quot;report.md&quot;: trigger &quot;missing&quot;
## Used non-default triggers. Some targets may be not be up to date.
</code></pre>

<p>You can choose from any of the following triggers for all targets or for each target individually.</p>

<ul>
<li><code>always</code>: Always build the target regardless of the circumstance, even if the target is already up to date. </li>
<li><code>any</code>: Apply all the triggers below (default). In other words, trigger a build if the <code>command</code> trigger, <code>depends</code> trigger, <code>file</code> trigger, or <code>missing</code> trigger is activated.</li>
<li><code>command</code>: Build if the workflow plan command changed since the last <code>make()</code> or the target is missing.</li>
<li><code>depends</code>: Build if any of the target&#39;s dependencies changed since the last <code>make()</code> or if the target is missing.</li>
<li><code>file</code>: Build if the target is an output file and the file is either missing or corrupted. Also build if the file&#39;s hash is missing from the cache.</li>
<li><code>missing</code>: Build if and only if the target is missing.</li>
</ul>

<p>To select triggers for individual targets, create an optional <code>trigger</code> column in the workflow plan data frame. Entries in this column override the <code>trigger</code> argument to <code>make()</code></p>

<pre><code class="r">my_plan$trigger &lt;- &quot;command&quot;
my_plan$trigger[1] &lt;- &quot;file&quot;
my_plan
## # A tibble: 15 x 3
##    target                 command                                  trigger
##    &lt;chr&gt;                  &lt;chr&gt;                                    &lt;chr&gt;  
##  1 &quot;&quot;                     &quot;knit(knitr_in(\&quot;report.Rmd\&quot;), file_ou~ file   
##  2 small                  simulate(48)                             command
##  3 large                  simulate(64)                             command
##  4 regression1_small      reg1(small)                              command
##  5 regression1_large      reg1(large)                              command
##  6 regression2_small      reg2(small)                              command
##  7 regression2_large      reg2(large)                              command
##  8 summ_regression1_small suppressWarnings(summary(regression1_sm~ command
##  9 summ_regression1_large suppressWarnings(summary(regression1_la~ command
## 10 summ_regression2_small suppressWarnings(summary(regression2_sm~ command
## 11 summ_regression2_large suppressWarnings(summary(regression2_la~ command
## 12 coef_regression1_small suppressWarnings(summary(regression1_sm~ command
## 13 coef_regression1_large suppressWarnings(summary(regression1_la~ command
## 14 coef_regression2_small suppressWarnings(summary(regression2_sm~ command
## 15 coef_regression2_large suppressWarnings(summary(regression2_la~ command

# Change an imported dependency:
reg2
## function(d) {
##   d$x3 &lt;- d$x ^ 3
##   lm(y ~ x3, data = d)
## }

reg2 &lt;- function(d) {
  d$x3 &lt;- d$x ^ 3
  lm(y ~ x3, data = d)
}
make(my_plan, trigger = &quot;any&quot;) # Nothing changes!
## Unloading targets from environment:
##   coef_regression2_small
##   large
##   small
## Used non-default triggers. Some targets may be not be up to date.
</code></pre>

<p>The <code>outdated()</code> function responds to triggers. For example, even if <code>outdated(my_plan)</code> shows all targets up to date, <code>outdated(my_plan, trigger = &quot;always&quot;)</code> will claim that all the targets are outdated.</p>

<h1>Skipping imports</h1>

<p>Similar to triggers, you can also to skip the processing of imported objects and files. However, <em>you should only use this for testing purposes</em>. If some of your imports are not already cached and up to date, any built targets will be out of sync. In other words, <code>outdated()</code> is more likely to be wrong, and your project may no longer be reproducible.</p>

<pre><code class="r">clean(verbose = FALSE)
my_plan$trigger &lt;- NULL

make(my_plan, skip_imports = TRUE)
## target large
## target small
## target regression1_large
## target regression1_small
## target regression2_large
## target regression2_small
## target coef_regression1_large
## target coef_regression1_small
## target coef_regression2_large
## target coef_regression2_small
## target summ_regression1_large
## target summ_regression1_small
## target summ_regression2_large
## target summ_regression2_small
## target file &quot;report.md&quot;
## Skipped the imports. If some imports are not already cached, targets could be out of date.
</code></pre>

<h1>Impose timeouts and retries</h1>

<p>See the <code>timeout</code>, <code>cpu</code>, <code>elapsed</code>, and <code>retries</code> argument to <code>make()</code>.</p>

<pre><code class="r">clean(verbose = FALSE)
f &lt;- function(...){
  Sys.sleep(1)
}
debug_plan &lt;- drake_plan(x = 1, y = f(x))
debug_plan
## # A tibble: 2 x 2
##   target command
##   &lt;chr&gt;  &lt;chr&gt;  
## 1 x      1      
## 2 y      f(x)

withr::with_message_sink(
  stdout(),
  make(debug_plan, timeout = 1e-3, retries = 2)
)
## Unloading targets from environment:
##   x
## target x
## [2018-03-22 13:13:17] TimeoutException: reached elapsed time limit
## [cpu=0.001s, elapsed=0.001s]
</code></pre>

<p>To tailor these settings to each individual target, create new <code>timeout</code>, <code>cpu</code>, <code>elapsed</code>, or <code>retries</code> columns in your workflow plan. These columns override the analogous arguments to <code>make()</code>.</p>

<pre><code class="r">clean(verbose = FALSE)
debug_plan$timeout &lt;- c(1e-3, 2e-3)
debug_plan$retries &lt;- 1:2

debug_plan
## # A tibble: 2 x 4
##   target command timeout retries
##   &lt;chr&gt;  &lt;chr&gt;     &lt;dbl&gt;   &lt;int&gt;
## 1 x      1       0.00100       1
## 2 y      f(x)    0.00200       2

withr::with_message_sink(
  new = stdout(),
  make(debug_plan, timeout = Inf, retries = 0)
)
## target x
## target y
## fail y
## Error: Target `y`` failed. Call `diagnose(y)` for details. Error message:
##   reached elapsed time limit
## Warning: No message sink to remove.
</code></pre>

<h1>Diagnose failures.</h1>

<p><code>Drake</code> records diagnostic metadata on all your targets, including the latest errors, warnings, messages, and other bits of context.</p>

<pre><code class="r">diagnose(verbose = FALSE) # Targets with available metadata.
## [1] &quot;Sys.sleep&quot; &quot;f&quot;         &quot;x&quot;         &quot;y&quot;

f &lt;- function(x){
  if (x &lt; 0){
    stop(&quot;`x` cannot be negative.&quot;)
  }
  x
}
bad_plan &lt;- drake_plan(
  a = 12,
  b = -a,
  my_target = f(b)
)

bad_plan
## # A tibble: 3 x 2
##   target    command
##   &lt;chr&gt;     &lt;chr&gt;  
## 1 a         12     
## 2 b         -a     
## 3 my_target f(b)

withr::with_message_sink(
  new = stdout(),
  make(bad_plan)
)
## target a
## target b
## target my_target
## fail my_target
## Error: Target `my_target`` failed. Call `diagnose(my_target)` for details. Error message:
##   `x` cannot be negative.
## Warning: No message sink to remove.

failed(verbose = FALSE) # from the last make() only
## [1] &quot;my_target&quot; &quot;y&quot;

# See also warnings and messages.
error &lt;- diagnose(my_target, verbose = FALSE)$error

error$message
## [1] &quot;`x` cannot be negative.&quot;

error$call
## f(b)

error$calls # View the traceback.
## [[1]]
## local({
##     f(b)
## })
## 
## [[2]]
## eval.parent(substitute(eval(quote(expr), envir)))
## 
## [[3]]
## eval(expr, p)
## 
## [[4]]
## eval(expr, p)
## 
## [[5]]
## eval(quote({
##     f(b)
## }), new.env())
## 
## [[6]]
## eval(quote({
##     f(b)
## }), new.env())
## 
## [[7]]
## f(b)
## 
## [[8]]
## stop(&quot;`x` cannot be negative.&quot;)
</code></pre>

<p>To figure out what went wrong, you could try to build the failed target interactively. To do that, simply call <code>drake_build()</code>. This function first calls <code>loadd(deps = TRUE)</code> to load any missing dependencies (see the <code>replace</code> argument here) and then builds your target.</p>

<pre><code class="r"># Pretend we just opened a new R session.
library(drake)

# Unloads target `b`.
config &lt;- drake_config(plan = bad_plan)
## Unloading targets from environment:
##   b

# my_target depends on b.
&quot;b&quot; %in% ls()
## [1] FALSE

# Try to build my_target until the error is fixed.
# Skip all that pesky work checking dependencies.
drake_build(my_target, config = config)
## target my_target
## fail my_target
## Error: Target `my_target`` failed. Call `diagnose(my_target)` for details. Error message:
##   `x` cannot be negative.

# The target failed, but the dependency was loaded.
&quot;b&quot; %in% ls()
## [1] TRUE

# What was `b` again?
b
## [1] -12

# How was `b` used?
diagnose(my_target)$message
## NULL

diagnose(my_target)$call
## NULL

f
## function(x){
##   if (x &lt; 0){
##     stop(&quot;`x` cannot be negative.&quot;)
##   }
##   x
## }

# Aha! The error was in f(). Let&#39;s fix it and try again.
f &lt;- function(x){
  x &lt;- abs(x)
  if (x &lt; 0){
    stop(&quot;`x` cannot be negative.&quot;)
  }
  x
}

# Now it works!
# Since you called make() previously, `config` is read from the cache
# if you do not supply it.
drake_build(my_target)
## target my_target

readd(my_target)
## [1] 12
</code></pre>

<h2>Tidy evaluation: a caveat to diagnosing interactively</h2>

<p>Running commands in your R console is not always exactly like running them with <code>make()</code>. That&#39;s because <code>make()</code> uses tidy evaluation as implemented in the <a href="https://github.com/tidyverse/rlang"><code>rlang</code> package</a>.</p>

<pre><code class="r"># This workflow plan uses rlang&#39;s quasiquotation operator `!!`.
my_plan &lt;- drake_plan(list = c(
  little_b = &quot;\&quot;b\&quot;&quot;,
  letter = &quot;!!little_b&quot;
))
my_plan
## # A tibble: 2 x 2
##   target   command   
##   &lt;chr&gt;    &lt;chr&gt;     
## 1 little_b &quot;\&quot;b\&quot;&quot;   
## 2 letter   !!little_b
make(my_plan)
## Unloading targets from environment:
##   little_b
##   letter
## target little_b
## target letter
readd(letter)
## [1] &quot;b&quot;
</code></pre>

<h1>Debrief a build session.</h1>

<p>After your project is at least somewhat built, you can inspect and read your results from the cache.</p>

<pre><code class="r">make(my_plan, verbose = FALSE)

# drake_session(verbose = FALSE) # Prints the sessionInfo() of the last make(). # nolint

cached(verbose = FALSE)
## [1] &quot;Sys.sleep&quot; &quot;a&quot;         &quot;b&quot;         &quot;f&quot;         &quot;letter&quot;    &quot;little_b&quot; 
## [7] &quot;my_target&quot; &quot;stop&quot;      &quot;x&quot;

built(verbose = FALSE)
## [1] &quot;a&quot;         &quot;b&quot;         &quot;letter&quot;    &quot;little_b&quot;  &quot;my_target&quot; &quot;x&quot;

imported(verbose = FALSE)
## [1] &quot;Sys.sleep&quot; &quot;f&quot;         &quot;stop&quot;

loadd(little_b, verbose = FALSE)

little_b
## [1] &quot;b&quot;

readd(letter, verbose = FALSE)
## [1] &quot;b&quot;

progress(verbose = FALSE)
## Error in progress(verbose = FALSE): unused argument (verbose = FALSE)

in_progress(verbose = FALSE) # Unfinished targets
## character(0)
</code></pre>

<p>There are functions to help you locate the project&#39;s cache.</p>

<pre><code class="r"># find_project() # nolint
# find_cache()   # nolint
</code></pre>

<p>For more information on the cache, see the <a href="https://github.com/ropensci/drake/blob/master/vignettes/storage.Rmd">storage vignette</a>.</p>

<h1>Start tinkering.</h1>

<p>The <code>load_basic_example()</code> function loads the <a href="https://github.com/ropensci/drake/tree/master/inst/examples/basic">basic example</a> from <code>drake_example(&quot;basic&quot;)</code> right into your workspace. The workflow plan data frame, workspace, and import files are set up for you. Only <code>make(my_plan)</code> is left to you.</p>

<p><code>Drake</code> has <a href="https://github.com/ropensci/drake/tree/master/inst/examples">many more built-in examples</a>. To see your choices, use</p>

<pre><code class="r">drake_examples()
## [1] &quot;Docker-psock&quot;     &quot;Makefile-cluster&quot; &quot;basic&quot;           
## [4] &quot;gsp&quot;              &quot;packages&quot;         &quot;sge&quot;             
## [7] &quot;slurm&quot;            &quot;torque&quot;
</code></pre>

<p>To write the files for an example, use <code>drake_example()</code>.</p>

<pre><code class="r">drake_example(&quot;basic&quot;)
drake_example(&quot;slurm&quot;)
</code></pre>

</body>

</html>

<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Quickstart examples</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1 align="center">
  <img width="200" src="../inst/logo.png" alt="" style = "border: none">
</h1>

<h1>Quickstart examples</h1>

<p>Drake has small self-contained built-in examples. To see the names of the available examples, use</p>

<pre><code class="r">examples_drake()
</code></pre>

<pre><code>## [1] &quot;basic&quot;
</code></pre>

<p>Then use <code>example_drake()</code> to write the files for the example to your working directory. This vignette walks through the <code>&quot;basic&quot;</code> example, for which you can get the code with</p>

<pre><code class="r">example_drake(&quot;basic&quot;)
</code></pre>

<h1>Setting up the basic example</h1>

<p>Load your libraries first. Drake will detect loaded packages and reload them on all your compute nodes, if applicable.</p>

<pre><code class="r">library(knitr)
library(rmarkdown)
library(drake)
</code></pre>

<p>This example is a simulation study, and we&#39;re using a function to simulate random datasets. Enter your simulation function and drake will import it automatically.</p>

<pre><code class="r">simulate = function(n){
  data.frame(
    x = rnorm(n),
    y = rpois(n, 1)
  )
}
</code></pre>

<p>For each dataset we simulate, we&#39;ll apply a bunch of methods of analysis.</p>

<pre><code class="r">reg1 = function(d){
  lm(y ~ + x, data = d)
}

reg2 = function(d){
  d$x2 = d$x^2
  lm(y ~ x2, data = d)
}
</code></pre>

<p>After we&#39;re done, we&#39;ll want to knit a dynamic <a href="http://rmarkdown.rstudio.com/">R Markdown</a> report with a bunch of results.</p>

<pre><code class="r">my_knit = function(file, ...){
  knit(file) # drake knows you loaded the knitr package
}

my_render = function(file, ...){
  render(file) # drake knows you loaded the rmarkdown package
}
</code></pre>

<p>The example provides an example <code>report.Rmd</code>, which uses <code>readd()</code> and <code>loadd()</code> to load objects we&#39;ll generate with drake.</p>

<pre><code class="r"># Write the R Markdown source for a dynamic knitr report
lines = c(
  &quot;---&quot;,
  &quot;title: Example Report&quot;,
  &quot;author: You&quot;,
  &quot;output: html_document&quot;,
  &quot;---&quot;,
  &quot;&quot;,
  &quot;Look how I read outputs from the drake cache.&quot;,
  &quot;&quot;,
  &quot;```{r example_chunk}&quot;,
  &quot;library(drake)&quot;,
  &quot;readd(small)&quot;,
  &quot;readd(coef_regression2_small)&quot;,
  &quot;loadd(large)&quot;,
  &quot;head(large)&quot;,
  &quot;```&quot;
)

writeLines(lines, &quot;report.Rmd&quot;)
</code></pre>

<h1>The workflow plan</h1>

<p>In drake, your workflow plan is organized into a data frame. Each row represents a target, which is either a variable or a file that will be produced with a single command. Here is the part of the plan that generates our datasets.</p>

<pre><code class="r">datasets = plan(
  small = simulate(5),
  large = simulate(50))
datasets
</code></pre>

<pre><code>##   target      command
## 1  small  simulate(5)
## 2  large simulate(50)
</code></pre>

<p>Commands need not be function calls. They can be any kind R expression except for formulas with <code>~</code> and function definitions. If I want multiple replicates, I can just use <code>expand</code>, but let&#39;s just stick to our two datasets here.</p>

<pre><code class="r">expand(datasets, values = c(&quot;rep1&quot;, &quot;rep2&quot;))
</code></pre>

<pre><code>##       target      command
## 1 small_rep1  simulate(5)
## 2 small_rep2  simulate(5)
## 3 large_rep1 simulate(50)
## 4 large_rep2 simulate(50)
</code></pre>

<p>To plan my analyses, we first declare the methods we will use.</p>

<pre><code class="r">methods = plan(
  regression1 = reg1(..dataset..),
  regression2 = reg2(..dataset..))
methods
</code></pre>

<pre><code>##        target           command
## 1 regression1 reg1(..dataset..)
## 2 regression2 reg2(..dataset..)
</code></pre>

<p>The wildcard placeholder <code>..dataset..</code> says to substitute the names of our datasets one at a time in our actual analysis plan.</p>

<pre><code class="r">analyses = analyses(methods, data = datasets)
analyses
</code></pre>

<pre><code>##              target     command
## 1 regression1_small reg1(small)
## 2 regression1_large reg1(large)
## 3 regression2_small reg2(small)
## 4 regression2_large reg2(large)
</code></pre>

<p>Now, we should summarize each analysis of each dataset a few different ways. </p>

<pre><code class="r">summary_types = plan(summ = summary(..analysis..),
                     coef = coef(..analysis..))
summary_types
</code></pre>

<pre><code>##   target               command
## 1   summ summary(..analysis..)
## 2   coef    coef(..analysis..)
</code></pre>

<pre><code class="r">results = summaries(summary_types, analyses, datasets, 
  gather = NULL)
results
</code></pre>

<pre><code>##                   target                    command
## 1 summ_regression1_small summary(regression1_small)
## 2 summ_regression1_large summary(regression1_large)
## 3 summ_regression2_small summary(regression2_small)
## 4 summ_regression2_large summary(regression2_large)
## 5 coef_regression1_small    coef(regression1_small)
## 6 coef_regression1_large    coef(regression1_large)
## 7 coef_regression2_small    coef(regression2_small)
## 8 coef_regression2_large    coef(regression2_large)
</code></pre>

<p>The <code>gather</code> argument of <code>summaries</code> is used to group summaries together by type, and I am skipping it here to make the workflow plan data frames more readable. The <code>..analysis..</code> wildcard acts similarly to the <code>..dataset..</code> wildcard. Functions <code>analyses()</code> and <code>summaries()</code> make use of <code>evaluate()</code> and <code>gather()</code> behind the scenes, which you can use them directly for added flexibility.</p>

<p>For the dynamic report, we have to tell drake which targets will be loaded into the embedded R chunks. That way, when the targets change, the report will automatically rebuild.</p>

<pre><code class="r">load_in_report = plan(
  report_dependencies = c(small, large, coef_regression2_small))
load_in_report
</code></pre>

<pre><code>##                target                                 command
## 1 report_dependencies c(small, large, coef_regression2_small)
</code></pre>

<p>In the commands to render the report, keep in mind the rule for working with files: use single quotes to declare external file targets and dependencies, and use double quotes to remove any special meaning from character strings. Single quotes inside any custom functions are ignored, so this mechanism only works for your workflow plan data frame. Also, please be aware that drake cannot track entire directories (folders).</p>

<pre><code class="r">report = plan(
  report.md = my_knit(&#39;report.Rmd&#39;, report_dependencies),
## The html report requires pandoc. Commented out.
## report.html = my_render(&#39;report.md&#39;, report_dependencies),
  file_targets = TRUE, strings_in_dots = &quot;filenames&quot;)
report
</code></pre>

<pre><code>##        target                                    command
## 1 &#39;report.md&#39; my_knit(&#39;report.Rmd&#39;, report_dependencies)
</code></pre>

<p>To finish planning your full workflow, use <code>rbind()</code> to piece all your commands together. Row order does not matter here. Drake knows which commands to run first.</p>

<pre><code class="r">plan = rbind(report, datasets, load_in_report, analyses, results)
plan
</code></pre>

<pre><code>##                    target                                    command
## 1             &#39;report.md&#39; my_knit(&#39;report.Rmd&#39;, report_dependencies)
## 2                   small                                simulate(5)
## 3                   large                               simulate(50)
## 4     report_dependencies    c(small, large, coef_regression2_small)
## 5       regression1_small                                reg1(small)
## 6       regression1_large                                reg1(large)
## 7       regression2_small                                reg2(small)
## 8       regression2_large                                reg2(large)
## 9  summ_regression1_small                 summary(regression1_small)
## 10 summ_regression1_large                 summary(regression1_large)
## 11 summ_regression2_small                 summary(regression2_small)
## 12 summ_regression2_large                 summary(regression2_large)
## 13 coef_regression1_small                    coef(regression1_small)
## 14 coef_regression1_large                    coef(regression1_large)
## 15 coef_regression2_small                    coef(regression2_small)
## 16 coef_regression2_large                    coef(regression2_large)
</code></pre>

<p>Use the <code>tracked()</code> function to list which objects, functions, files, targets, etc. that drake tries to reporducibly track. (I say &ldquo;tries&rdquo; because if you mention a symbol in a command or function but drake cannot find it, drake will skip it, and if verbose is <code>TRUE</code>, you will be notified.) Drake is not perfect, and it can miss dependencies in some edge cases, so you should inspect the output of <code>tracked()</code>. (See also <code>build_graph()</code> and <code>plot_graph()</code> to inspect the dependency tree of your project.)</p>

<pre><code class="r">&quot;small&quot; %in% tracked(plan)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">tracked(plan, targets = &quot;small&quot;)
</code></pre>

<pre><code>## [1] &quot;small&quot;      &quot;simulate&quot;   &quot;data.frame&quot; &quot;rnorm&quot;      &quot;rpois&quot;
</code></pre>

<pre><code class="r">tracked(plan)
</code></pre>

<pre><code>##  [1] &quot;&#39;report.md&#39;&quot;            &quot;small&quot;                 
##  [3] &quot;large&quot;                  &quot;report_dependencies&quot;   
##  [5] &quot;regression1_small&quot;      &quot;regression1_large&quot;     
##  [7] &quot;regression2_small&quot;      &quot;regression2_large&quot;     
##  [9] &quot;summ_regression1_small&quot; &quot;summ_regression1_large&quot;
## [11] &quot;summ_regression2_small&quot; &quot;summ_regression2_large&quot;
## [13] &quot;coef_regression1_small&quot; &quot;coef_regression1_large&quot;
## [15] &quot;coef_regression2_small&quot; &quot;coef_regression2_large&quot;
## [17] &quot;my_knit&quot;                &quot;simulate&quot;              
## [19] &quot;reg1&quot;                   &quot;reg2&quot;                  
## [21] &quot;&#39;report.Rmd&#39;&quot;           &quot;c&quot;                     
## [23] &quot;summary&quot;                &quot;coef&quot;                  
## [25] &quot;knit&quot;                   &quot;data.frame&quot;            
## [27] &quot;rnorm&quot;                  &quot;rpois&quot;                 
## [29] &quot;lm&quot;
</code></pre>

<p>Check your workflow plan for other errors and pitfalls, such as circularities and possibly missed file dependencies.</p>

<pre><code class="r">check(plan)
</code></pre>

<h1>Run the workflow in a single process</h1>

<p>Use <code>make(plan)</code> to run your workflow.</p>

<pre><code class="r">make(plan)
</code></pre>

<pre><code>## import &#39;report.Rmd&#39;
## import c
## import summary
## import coef
## import lm
## import data.frame
## import rnorm
## import rpois
## import knit
## import reg2
## import reg1
## import simulate
## import my_knit
## build small
## build large
## build regression1_small
## build regression1_large
## build regression2_small
## build regression2_large
## build summ_regression1_small
## build summ_regression1_large
## build summ_regression2_small
## build summ_regression2_large
## build coef_regression1_small
## build coef_regression1_large
## build coef_regression2_small
## build coef_regression2_large
## build report_dependencies
## build &#39;report.md&#39;
</code></pre>

<pre><code>## processing file: report.Rmd
</code></pre>

<pre><code>## output file: report.md
</code></pre>

<p>Use <code>readd()</code> and <code>loadd()</code> to see the targets you generated. (They are stored in the hidden <code>.drake/</code> folder using <a href="https://CRAN.R-project.org/package=storr">storr</a>). Other functions interact and view the cache.</p>

<pre><code class="r">readd(coef_regression2_large)
</code></pre>

<pre><code>## (Intercept)          x2 
##  1.20982042  0.05446556
</code></pre>

<pre><code class="r">loadd(small)
head(small)
</code></pre>

<pre><code>##              x y
## 1 -0.026859063 0
## 2 -0.382923352 1
## 3 -0.008254466 3
## 4  1.507813110 1
## 5 -0.084409867 1
</code></pre>

<pre><code class="r">rm(small)
cached(small, large)
</code></pre>

<pre><code>## small large 
##  TRUE  TRUE
</code></pre>

<pre><code class="r">cached()
</code></pre>

<pre><code>##  [1] &quot;&#39;report.Rmd&#39;&quot;           &quot;&#39;report.md&#39;&quot;           
##  [3] &quot;c&quot;                      &quot;coef&quot;                  
##  [5] &quot;coef_regression1_large&quot; &quot;coef_regression1_small&quot;
##  [7] &quot;coef_regression2_large&quot; &quot;coef_regression2_small&quot;
##  [9] &quot;data.frame&quot;             &quot;knit&quot;                  
## [11] &quot;large&quot;                  &quot;lm&quot;                    
## [13] &quot;my_knit&quot;                &quot;reg1&quot;                  
## [15] &quot;reg2&quot;                   &quot;regression1_large&quot;     
## [17] &quot;regression1_small&quot;      &quot;regression2_large&quot;     
## [19] &quot;regression2_small&quot;      &quot;report_dependencies&quot;   
## [21] &quot;rnorm&quot;                  &quot;rpois&quot;                 
## [23] &quot;simulate&quot;               &quot;small&quot;                 
## [25] &quot;summ_regression1_large&quot; &quot;summ_regression1_small&quot;
## [27] &quot;summ_regression2_large&quot; &quot;summ_regression2_small&quot;
## [29] &quot;summary&quot;
</code></pre>

<pre><code class="r">built()
</code></pre>

<pre><code>##  [1] &quot;&#39;report.md&#39;&quot;            &quot;coef_regression1_large&quot;
##  [3] &quot;coef_regression1_small&quot; &quot;coef_regression2_large&quot;
##  [5] &quot;coef_regression2_small&quot; &quot;large&quot;                 
##  [7] &quot;regression1_large&quot;      &quot;regression1_small&quot;     
##  [9] &quot;regression2_large&quot;      &quot;regression2_small&quot;     
## [11] &quot;report_dependencies&quot;    &quot;small&quot;                 
## [13] &quot;summ_regression1_large&quot; &quot;summ_regression1_small&quot;
## [15] &quot;summ_regression2_large&quot; &quot;summ_regression2_small&quot;
</code></pre>

<pre><code class="r">imported()
</code></pre>

<pre><code>##  [1] &quot;&#39;report.Rmd&#39;&quot; &quot;c&quot;            &quot;coef&quot;         &quot;data.frame&quot;  
##  [5] &quot;knit&quot;         &quot;lm&quot;           &quot;my_knit&quot;      &quot;reg1&quot;        
##  [9] &quot;reg2&quot;         &quot;rnorm&quot;        &quot;rpois&quot;        &quot;simulate&quot;    
## [13] &quot;summary&quot;
</code></pre>

<pre><code class="r">head(read_plan())
</code></pre>

<pre><code>##                target                                    command
## 1         &#39;report.md&#39; my_knit(&#39;report.Rmd&#39;, report_dependencies)
## 2               small                                simulate(5)
## 3               large                               simulate(50)
## 4 report_dependencies    c(small, large, coef_regression2_small)
## 5   regression1_small                                reg1(small)
## 6   regression1_large                                reg1(large)
</code></pre>

<pre><code class="r"># read_graph() # reads/plots the tree structure of your workflow plan
head(status()) # last call to make()
</code></pre>

<pre><code>##           &#39;report.Rmd&#39;            &#39;report.md&#39;                      c 
##             &quot;finished&quot;             &quot;finished&quot;             &quot;finished&quot; 
##                   coef coef_regression1_large coef_regression1_small 
##             &quot;finished&quot;             &quot;finished&quot;             &quot;finished&quot;
</code></pre>

<pre><code class="r">status(large)
</code></pre>

<pre><code>##      large 
## &quot;finished&quot;
</code></pre>

<p>The next time you run <code>make(plan)</code>, nothing will be built because drake knows everything is up to date.</p>

<pre><code class="r">make(plan)
</code></pre>

<pre><code>## import &#39;report.Rmd&#39;
## import c
## import summary
## import coef
## import lm
## import data.frame
## import rnorm
## import rpois
## import knit
## import reg2
## import reg1
## import simulate
## import my_knit
</code></pre>

<p>But if you change one of your functions, commands, or other dependencies, drake will update the affected parts of the workflow. Let&#39;s say we want to change the quadratic term to a cubic term in our <code>reg2()</code> function.</p>

<pre><code class="r">reg2 = function(d){
  d$x3 = d$x^3
  lm(y ~ x3, data = d)
}
</code></pre>

<p>Voila! Targets depending on <code>reg2()</code> are updated, and those depending only on <code>reg1()</code> are left alone.</p>

<pre><code class="r">make(plan)
</code></pre>

<pre><code>## import &#39;report.Rmd&#39;
## import c
## import summary
## import coef
## import lm
## import data.frame
## import rnorm
## import rpois
## import knit
## import reg2
## import reg1
## import simulate
## import my_knit
## build regression2_small
## build regression2_large
## build summ_regression2_small
## build summ_regression2_large
## build coef_regression2_small
## build coef_regression2_large
## build report_dependencies
## build &#39;report.md&#39;
</code></pre>

<pre><code>## processing file: report.Rmd
</code></pre>

<pre><code>## output file: report.md
</code></pre>

<p>But trivial changes such whitespace and comments are totally ignored in your functions and in <code>plan$command</code>.</p>

<pre><code class="r">reg2 = function(d){
  d$x3 = d$x^3
    lm(y ~ x3, data = d) # I indented here.
}
make(plan) 
</code></pre>

<pre><code>## import &#39;report.Rmd&#39;
## import c
## import summary
## import coef
## import lm
## import data.frame
## import rnorm
## import rpois
## import knit
## import reg2
## import reg1
## import simulate
## import my_knit
</code></pre>

<h1>Need to add new work on the fly?</h1>

<p>Just append rows to the workflow plan. If the rest of your workflow is up to date, only the new work is run.</p>

<pre><code class="r">new_simulation = function(n){
  data.frame(x = rnorm(n), y = rnorm(n))
}

additions = plan(
  new_data = new_simulation(36) + sqrt(10))  
additions
</code></pre>

<pre><code>##     target                       command
## 1 new_data new_simulation(36) + sqrt(10)
</code></pre>

<pre><code class="r">plan = rbind(plan, additions)
plan
</code></pre>

<pre><code>##                    target                                    command
## 1             &#39;report.md&#39; my_knit(&#39;report.Rmd&#39;, report_dependencies)
## 2                   small                                simulate(5)
## 3                   large                               simulate(50)
## 4     report_dependencies    c(small, large, coef_regression2_small)
## 5       regression1_small                                reg1(small)
## 6       regression1_large                                reg1(large)
## 7       regression2_small                                reg2(small)
## 8       regression2_large                                reg2(large)
## 9  summ_regression1_small                 summary(regression1_small)
## 10 summ_regression1_large                 summary(regression1_large)
## 11 summ_regression2_small                 summary(regression2_small)
## 12 summ_regression2_large                 summary(regression2_large)
## 13 coef_regression1_small                    coef(regression1_small)
## 14 coef_regression1_large                    coef(regression1_large)
## 15 coef_regression2_small                    coef(regression2_small)
## 16 coef_regression2_large                    coef(regression2_large)
## 17               new_data              new_simulation(36) + sqrt(10)
</code></pre>

<pre><code class="r">make(plan)
</code></pre>

<pre><code>## import &#39;report.Rmd&#39;
## import c
## import summary
## import coef
## import sqrt
## import lm
## import data.frame
## import rnorm
## import rpois
## import knit
## import reg2
## import reg1
## import simulate
## import my_knit
## import new_simulation
## build new_data
</code></pre>

<p>To clean up, use <code>clean()</code>. Any targets removed from the cache will have to be rebuilt on the next call to <code>make()</code>, so only clean if you are sure you will not lose anything important.</p>

<pre><code class="r">clean(small, reg1) # uncaches individual targets and imported objects
clean() # cleans all targets out of the cache
clean(destroy = TRUE) # removes the cache entirely
</code></pre>

<h1>High-performance parallel computing</h1>

<p>Within a single R session and a single compute node, you can spread your work over multiple parallel processes. Select the type of parallel computing with the <code>parallelism</code> argument to <code>make()</code>, and select the maximum number of parallel tasks with the <code>jobs</code> argument. Set <code>parallelism = &quot;parLapply&quot;</code> (default for Windows) to use <code>parallel::parLapply()</code> in the backend. This approach works on most (if not all) platforms, but setting up the local cluster at the beginning takes extra time. Users with non-Windows platforms can set <code>parallelism = &quot;mclapply&quot;</code> (non-Windows default) to use <code>parallel::mclapply()</code> on the backend, which requires less overhead.</p>

<pre><code class="r">make(plan, jobs = 2) # parallelism == &quot;parLapply&quot; by default.
make(plan, parallelism = &quot;mclapply&quot;, jobs = 2) # not for Windows
readd(coef_regression2_large)
</code></pre>

<p>Alternatively, set <code>parallelism = &quot;Makefile&quot;</code> to spread targets over multiple parallel R sessions. This gets into true distributed computing. Windows users will need to download and install <a href="https://cran.r-project.org/bin/windows/Rtools/"><code>Rtools</code></a>. The following are equivalent.</p>

<pre><code class="r">make(plan, parallelism = &quot;Makefile&quot;, jobs = 4, verbose = FALSE)
make(plan, parallelism = &quot;Makefile&quot;, command = &quot;make&quot;, args = &quot;--jobs=4 --silent&quot;) 
</code></pre>

<p>To distribute those <a href="http://kbroman.org/minimal_make/">Makefile</a> jobs over multiple nodes on a cluster or supercomputer, you may need a <code>shell.sh</code> file like the following</p>

<pre><code class="r">#!/bin/bash
shift
echo &quot;module load R; $*&quot; | qsub -sync y -cwd -j y
</code></pre>

<p>You may need to replace <code>module load R</code> with a command to load a specific version of R. Next, put your main code, including your call to <code>make(plan, ...)</code>, inside an R script such as <code>script.R</code>. </p>

<p>To run your workflow on the cluster, use the <a href="https://www.howtogeek.com/140679/beginner-geek-how-to-start-using-the-linux-terminal/">Linux terminal</a> to enter the following.</p>

<pre><code class="r">nohup nice -19 R CMD BATCH script.R &amp;
</code></pre>

<p>Even after you log out, a background process will remain on the login node to submit new jobs through <a href="http://kbroman.org/minimal_make/">Make</a> as new targets become ready.</p>

<h1>A warning about the Makefile</h1>

<p>The <a href="http://kbroman.org/minimal_make/">Makefile</a> generated by <code>make(plan, parallelism = &quot;Makefile&quot;)</code> is not standalone. Do not run it outside of <code>drake::make()</code>. Drake uses dummy timestamp files to tell the <a href="http://kbroman.org/minimal_make/">Makefile</a> what to do, and running <code>make</code> in the <a href="https://www.howtogeek.com/140679/beginner-geek-how-to-start-using-the-linux-terminal/">terminal</a> will most likely give incorrect results.</p>

<h1>Flexible generation of workflow plans</h1>

<h2>More flexibility for generating workflow plans</h2>

<p>If your workflow does not fit the rigid datasets/analyses/summaries framework, check out functions <code>expand()</code>, <code>evaluate()</code>, and <code>gather()</code>.</p>

<pre><code class="r">df = plan(data = simulate(center = MU, scale = SIGMA))
df
</code></pre>

<pre><code>##   target                              command
## 1   data simulate(center = MU, scale = SIGMA)
</code></pre>

<pre><code class="r">df = expand(df, values = c(&quot;rep1&quot;, &quot;rep2&quot;))
df
</code></pre>

<pre><code>##      target                              command
## 1 data_rep1 simulate(center = MU, scale = SIGMA)
## 2 data_rep2 simulate(center = MU, scale = SIGMA)
</code></pre>

<pre><code class="r">evaluate(df, wildcard = &quot;MU&quot;, values = 1:2)
</code></pre>

<pre><code>##        target                             command
## 1 data_rep1_1 simulate(center = 1, scale = SIGMA)
## 2 data_rep1_2 simulate(center = 2, scale = SIGMA)
## 3 data_rep2_1 simulate(center = 1, scale = SIGMA)
## 4 data_rep2_2 simulate(center = 2, scale = SIGMA)
</code></pre>

<pre><code class="r">evaluate(df, wildcard = &quot;MU&quot;, values = 1:2, expand = FALSE)
</code></pre>

<pre><code>##      target                             command
## 1 data_rep1 simulate(center = 1, scale = SIGMA)
## 2 data_rep2 simulate(center = 2, scale = SIGMA)
</code></pre>

<pre><code class="r">evaluate(df, rules = list(MU = 1:2, SIGMA = c(0.1, 1)), expand = FALSE)
</code></pre>

<pre><code>##      target                           command
## 1 data_rep1 simulate(center = 1, scale = 0.1)
## 2 data_rep2   simulate(center = 2, scale = 1)
</code></pre>

<pre><code class="r">evaluate(df, rules = list(MU = 1:2, SIGMA = c(0.1, 1, 10)))
</code></pre>

<pre><code>##             target                           command
## 1  data_rep1_1_0.1 simulate(center = 1, scale = 0.1)
## 2    data_rep1_1_1   simulate(center = 1, scale = 1)
## 3   data_rep1_1_10  simulate(center = 1, scale = 10)
## 4  data_rep1_2_0.1 simulate(center = 2, scale = 0.1)
## 5    data_rep1_2_1   simulate(center = 2, scale = 1)
## 6   data_rep1_2_10  simulate(center = 2, scale = 10)
## 7  data_rep2_1_0.1 simulate(center = 1, scale = 0.1)
## 8    data_rep2_1_1   simulate(center = 1, scale = 1)
## 9   data_rep2_1_10  simulate(center = 1, scale = 10)
## 10 data_rep2_2_0.1 simulate(center = 2, scale = 0.1)
## 11   data_rep2_2_1   simulate(center = 2, scale = 1)
## 12  data_rep2_2_10  simulate(center = 2, scale = 10)
</code></pre>

<pre><code class="r">gather(df)
</code></pre>

<pre><code>##   target                                            command
## 1 target list(data_rep1 = data_rep1, data_rep2 = data_rep2)
</code></pre>

<pre><code class="r">gather(df, target = &quot;my_summaries&quot;, gather = &quot;rbind&quot;)
</code></pre>

<pre><code>##         target                                             command
## 1 my_summaries rbind(data_rep1 = data_rep1, data_rep2 = data_rep2)
</code></pre>

</body>

</html>

<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Storage basics</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p><code>Drake</code>&#39;s <code>make()</code> function generates your project&#39;s output, and <code>drake</code> takes storing this output seriously. This guide explains how <code>drake</code> caches and hashes its data, and describes customization options that can increase convenience and speed.</p>

<h1>Storage basics</h1>

<p>When you run <code>make()</code>, <code>drake</code> stores your imports and output targets in a hidden cache.</p>

<pre><code class="r">library(drake)
load_basic_example(verbose = FALSE) # Get the code with drake_example(&quot;basic&quot;).
config &lt;- make(my_plan, verbose = FALSE)
</code></pre>

<p>You can explore your cached data using functions like <code>loadd()</code>, <code>readd()</code>, and <code>cached()</code>.</p>

<pre><code class="r">head(cached())
## [1] &quot;\&quot;report.Rmd\&quot;&quot;         &quot;\&quot;report.md\&quot;&quot;         
## [3] &quot;coef_regression1_large&quot; &quot;coef_regression1_small&quot;
## [5] &quot;coef_regression2_large&quot; &quot;coef_regression2_small&quot;

head(readd(small))
##       x    y
## 1 3.730 17.3
## 2 5.250 10.4
## 3 3.730 17.3
## 4 5.345 14.7
## 5 3.190 24.4
## 6 3.440 17.8

loadd(large)

head(large)
##       x    y
## 1 3.780 15.2
## 2 3.170 15.8
## 3 5.424 10.4
## 4 5.250 10.4
## 5 3.780 15.2
## 6 3.570 14.3

rm(large) # Does not remove `large` from the cache.
</code></pre>

<h1>Caches as R objects</h1>

<p>The <a href="https://github.com/richfitz/storr">storr</a> package does the heavy lifting. A <code>storr</code> is an object in R that serves as an abstraction for a storage backend, usually a file system. See the <a href="https://cran.r-project.org/package=storr/vignettes/storr.html">main storr vignette</a> for a thorough walkthrough.</p>

<pre><code class="r">class(config$cache) # from `config &lt;- make(...)`
## [1] &quot;storr&quot; &quot;R6&quot;

cache &lt;- get_cache() # Get the default cache from the last build.

class(cache)
## [1] &quot;storr&quot; &quot;R6&quot;

cache$list() # Functionality from storr
##  [1] &quot;\&quot;report.Rmd\&quot;&quot;         &quot;\&quot;report.md\&quot;&quot;         
##  [3] &quot;coef_regression1_large&quot; &quot;coef_regression1_small&quot;
##  [5] &quot;coef_regression2_large&quot; &quot;coef_regression2_small&quot;
##  [7] &quot;data.frame&quot;             &quot;knit&quot;                  
##  [9] &quot;large&quot;                  &quot;lm&quot;                    
## [11] &quot;mtcars&quot;                 &quot;nrow&quot;                  
## [13] &quot;random_rows&quot;            &quot;reg1&quot;                  
## [15] &quot;reg2&quot;                   &quot;regression1_large&quot;     
## [17] &quot;regression1_small&quot;      &quot;regression2_large&quot;     
## [19] &quot;regression2_small&quot;      &quot;sample.int&quot;            
## [21] &quot;simulate&quot;               &quot;small&quot;                 
## [23] &quot;summ_regression1_large&quot; &quot;summ_regression1_small&quot;
## [25] &quot;summ_regression2_large&quot; &quot;summ_regression2_small&quot;
## [27] &quot;summary&quot;                &quot;suppressWarnings&quot;

head(cache$get(&quot;small&quot;)) # Functionality from storr
##       x    y
## 1 3.730 17.3
## 2 5.250 10.4
## 3 3.730 17.3
## 4 5.345 14.7
## 5 3.190 24.4
## 6 3.440 17.8
</code></pre>

<h1>Hash algorithms</h1>

<p>The concept of <a href="https://en.wikipedia.org/wiki/Hash_function">hashing</a> is central to <a href="https://github.com/richfitz/storr">storr</a>&#39;s internals. <a href="https://github.com/richfitz/storr">Storr</a> uses hashes to label stored objects, and <code>drake</code> leverages these hashes to figure out which targets are up to date and which ones are outdated. A hash is like a target&#39;s fingerprint, so the hash changes when the target changes. Regardless of the target&#39;s size, the hash is always the same number of characters.</p>

<pre><code class="r">library(digest) # package for hashing objects and files
smaller_data &lt;- 12
larger_data &lt;- rnorm(1000)

digest(smaller_data) # compute the hash
## [1] &quot;23c80a31c0713176016e6e18d76a5f31&quot;

digest(larger_data)
## [1] &quot;f2b2f4bef0888e67f304184fc6b38ab7&quot;
</code></pre>

<p>However, different hash algorithms vary in length.</p>

<pre><code class="r">digest(larger_data, algo = &quot;sha512&quot;)
## [1] &quot;335941c74a80d61d95a3c9d9338c3012c7d4c7045223b866ee5ca1435763b2f028d676ac93d7a3ad86945da7eaae6a514aa75e00b378bf114dd4f213e5f8ff7c&quot;

digest(larger_data, algo = &quot;md5&quot;)
## [1] &quot;f2b2f4bef0888e67f304184fc6b38ab7&quot;

digest(larger_data, algo = &quot;xxhash64&quot;)
## [1] &quot;4c78893ea3b0de86&quot;

digest(larger_data, algo = &quot;murmur32&quot;)
## [1] &quot;cbd6c247&quot;
</code></pre>

<h1>Which hash algorithm should you choose?</h1>

<p>Hashing is expensive, and unsurprisingly, shorter hashes are usually faster to compute. So why not always use <code>murmur32</code>? One reason is the risk of collisions: that is, when two different objects have the same hash. In general, shorter hashes have more frequent collisions. On the other hand, a longer hash is not always the answer. Besides the loss of speed, <code>drake</code> and <a href="https://github.com/richfitz/storr">storr</a> sometimes use hash keys as file names, and long hashes could violate the 260-character cap on Windows file paths. That is why <code>drake</code> uses a shorter hash algorithm for internal cache-related file names and a longer hash algorithm for everything else.</p>

<pre><code class="r">default_short_hash_algo()
## [1] &quot;xxhash64&quot;

default_long_hash_algo()
## [1] &quot;sha256&quot;

short_hash(cache)
## [1] &quot;xxhash64&quot;

long_hash(cache)
## [1] &quot;sha256&quot;
</code></pre>

<h1>Select the hash algorithms of the default cache</h1>

<p>For new projects, use <code>new_cache()</code> to set the hash algorithms of the default cache.</p>

<pre><code class="r"># cache_path(cache) # Default cache from before. # nolint

# Start from scratch to reset both hash algorithms.
clean(destroy = TRUE)

tmp &lt;- new_cache(
  path = default_cache_path(), # The `.drake/` folder.
  short_hash_algo = &quot;crc32&quot;,
  long_hash_algo = &quot;sha1&quot;
)
</code></pre>

<p>The cache at <code>default_cache_path()</code> (equivalently, the <code>.drake/</code> folder) is the default cache used for <code>make()</code>.</p>

<pre><code class="r">config &lt;- make(my_plan, verbose = FALSE)

short_hash(config$cache) # xxhash64 is the default_short_hash_algo()
## [1] &quot;crc32&quot;

long_hash(config$cache) # sha256 is the default_long_hash_algo()
## [1] &quot;sha1&quot;
</code></pre>

<p>You can change the long hash algorithm without throwing away the cache, but your project will rebuild from scratch. As for the short hash, you are committed until you delete the cache and all its supporting files.</p>

<pre><code class="r">outdated(config) # empty
## character(0)

config$cache &lt;- configure_cache(
  config$cache,
  long_hash_algo = &quot;murmur32&quot;,
  overwrite_hash_algos = TRUE
)
</code></pre>

<p>Below, the targets become outdated because the existing hash keys do not match the new hash algorithm.</p>

<pre><code class="r">config &lt;- drake_config(my_plan, verbose = FALSE, cache = config$cache)
outdated(config)
##  [1] &quot;\&quot;report.md\&quot;&quot;          &quot;coef_regression1_large&quot;
##  [3] &quot;coef_regression1_small&quot; &quot;coef_regression2_large&quot;
##  [5] &quot;coef_regression2_small&quot; &quot;large&quot;                 
##  [7] &quot;regression1_large&quot;      &quot;regression1_small&quot;     
##  [9] &quot;regression2_large&quot;      &quot;regression2_small&quot;     
## [11] &quot;small&quot;                  &quot;summ_regression1_large&quot;
## [13] &quot;summ_regression1_small&quot; &quot;summ_regression2_large&quot;
## [15] &quot;summ_regression2_small&quot;

config &lt;- make(my_plan, verbose = FALSE)

short_hash(config$cache) # same as before
## [1] &quot;crc32&quot;

long_hash(config$cache) # different from before
## [1] &quot;murmur32&quot;
</code></pre>

<h1>More on custom caches</h1>

<p>You do not need to use the default cache at the <code>default_cache_path()</code> (<code>.drake/</code>). However, if you use a different file system, such as the custom <code>faster_cache/</code> folder below, you will need to manually supply the cache to all functions that require one.</p>

<pre><code class="r">faster_cache &lt;- new_cache(
  path = &quot;faster_cache&quot;,
  short_hash_algo = &quot;murmur32&quot;,
  long_hash_algo = &quot;murmur32&quot;
)

# cache_path(faster_cache) # nolint
# cache_path(cache) # location of the previous cache # nolint

short_hash(faster_cache)
## [1] &quot;murmur32&quot;

long_hash(faster_cache)
## [1] &quot;murmur32&quot;

new_plan &lt;- drake_plan(
  simple = 1 + 1
)

make(new_plan, cache = faster_cache)
## target simple

cached(cache = faster_cache)
## [1] &quot;simple&quot;

readd(simple, cache = faster_cache)
## [1] 2
</code></pre>

<h1>Recovering the cache</h1>

<p>You can recover an old cache from the file system. You could use <code>storr::storr_rds()</code> directly if you know the short hash algorithm, but <code>this_cache()</code> and <code>recover_cache()</code> are safer for <code>drake</code>. <code>get_cache()</code> is similar, but it has a slightly different interface.</p>

<pre><code class="r">old_cache &lt;- this_cache(&quot;faste_cache&quot;) # Get a cache you know exists...
recovered &lt;- recover_cache(&quot;faster_cache&quot;) # or create a new one if missing.
</code></pre>

<h1>Custom <a href="https://github.com/richfitz/storr">storr</a> caches</h1>

<p>If you want bypass <code>drake</code> and generate a cache directly from <a href="https://github.com/richfitz/storr">storr</a>, it is best to do so right from the beginning.</p>

<pre><code class="r">library(storr)
my_storr &lt;- storr_rds(&quot;my_storr&quot;, mangle_key = TRUE)
make(new_plan, cache = my_storr)
## Unloading targets from environment:
##   simple
## target simple

cached(cache = my_storr)
## [1] &quot;simple&quot;

readd(simple, cache = my_storr)
## [1] 2
</code></pre>

<p>In addition to <code>storr_rds()</code>, <code>drake</code> supports in-memory caches created from <code>storr_environment()</code>. However, parallel computing is not supported these caches. The <code>jobs</code> argument must be 1, and the <code>parallelism</code> argument must be either <code>&quot;mclapply&quot;</code> or <code>&quot;parLapply&quot;</code>. (It is sufficient to leave the default values alone.)</p>

<pre><code class="r">memory_cache &lt;- storr_environment()
other_plan &lt;- drake_plan(
  some_data = rnorm(50),
  more_data = rpois(75, lambda = 10),
  result = mean(c(some_data, more_data))
)

make(other_plan, cache = memory_cache)
## target more_data
## target some_data
## target result

cached(cache = memory_cache)
## [1] &quot;c&quot;         &quot;mean&quot;      &quot;more_data&quot; &quot;result&quot;    &quot;rnorm&quot;     &quot;rpois&quot;    
## [7] &quot;some_data&quot;

readd(result, cache = memory_cache)
## [1] 6.232917
</code></pre>

<p>In theory, it should be possible to leverage serious databases using <code>storr_dbi()</code>. However, if you use such caches, please heed the following.</p>

<ol>
<li>Be sure you have <a href="https://github.com/richfitz/storr">storr</a> version 1.1.3 or greater installed.</li>
<li>Be careful about parallel computing. For example the <code>storr::storr_dbi()</code> cache is not thread-safe. Either use no parallel computing at all or set <code>parallelism = &quot;future&quot;</code> with <code>caching = &quot;master&quot;</code>. The <code>&quot;future&quot;</code> backend is currently experimental, but it allows the master process to do all the caching in order to avoid race conditions.</li>
</ol>

<p>The following example requires the <code>DBI</code> and <code>RSQLite</code> packages.</p>

<pre><code class="r">mydb &lt;- DBI::dbConnect(RSQLite::SQLite(), &quot;my-db.sqlite&quot;)
cache &lt;- storr::storr_dbi(
  tbl_data = &quot;data&quot;,
  tbl_keys = &quot;keys&quot;,
  con = mydb
)
load_basic_example() # Get the code with drake_example(&quot;basic&quot;).
unlink(&quot;.drake&quot;, recursive = TRUE)
make(my_plan, cache = cache)
</code></pre>

<h1>Cleaning up</h1>

<p>If you want to start from scratch, you can <code>clean()</code> the cache. Use the <code>destroy</code> argument to remove it completely. <code>cache$del()</code> and <code>cache$destroy()</code> are also options, but they leave output file targets dangling. By contrast, <code>clean(destroy = TRUE)</code> removes file targets generated by <code>drake::make()</code>. <code>drake_gc()</code> and <code>clean(..., garbage_collection = TRUE)</code> do garbage collection, and <code>clean(purge = TRUE)</code> removes all target-level data, not just the final output values.</p>

<pre><code class="r">clean(small, large)

cached() # &#39;small&#39; and &#39;large&#39; are gone
##  [1] &quot;\&quot;report.Rmd\&quot;&quot;         &quot;\&quot;report.md\&quot;&quot;         
##  [3] &quot;coef_regression1_large&quot; &quot;coef_regression1_small&quot;
##  [5] &quot;coef_regression2_large&quot; &quot;coef_regression2_small&quot;
##  [7] &quot;data.frame&quot;             &quot;knit&quot;                  
##  [9] &quot;lm&quot;                     &quot;mtcars&quot;                
## [11] &quot;nrow&quot;                   &quot;random_rows&quot;           
## [13] &quot;reg1&quot;                   &quot;reg2&quot;                  
## [15] &quot;regression1_large&quot;      &quot;regression1_small&quot;     
## [17] &quot;regression2_large&quot;      &quot;regression2_small&quot;     
## [19] &quot;sample.int&quot;             &quot;simulate&quot;              
## [21] &quot;summ_regression1_large&quot; &quot;summ_regression1_small&quot;
## [23] &quot;summ_regression2_large&quot; &quot;summ_regression2_small&quot;
## [25] &quot;summary&quot;                &quot;suppressWarnings&quot;

clean(destroy = TRUE)

clean(destroy = TRUE, cache = faster_cache)
clean(destroy = TRUE, cache = my_storr)
</code></pre>

</body>

</html>
